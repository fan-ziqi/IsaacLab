# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022-2024, The Isaac Lab Project Developers.
# This file is distributed under the same license as the Isaac Lab package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
msgid ""
msgstr ""
"Project-Id-Version: Isaac Lab 1.0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-30 10:41+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Ziqi Fan <fanziqi614@gmail.com>\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Generated-By: Babel 2.17.0\n"

#: ../../source/how-to/write_articulation_cfg.rst:5
msgid "Writing an Asset Configuration"
msgstr "编写资产配置"

#: ../../source/how-to/write_articulation_cfg.rst:9
msgid ""
"This guide walks through the process of creating an "
":class:`~assets.ArticulationCfg`. The :class:`~assets.ArticulationCfg` is a "
"configuration object that defines the properties of an "
":class:`~assets.Articulation` in Isaac Lab."
msgstr ""
"本指南详细介绍了创建 :class:`~assets.ArticulationCfg` 的过程。 "
":class:`~assets.ArticulationCfg` 是定义Isaac Lab中 :class:`~assets.Articulation`"
" 属性的配置对象。"

#: ../../source/how-to/write_articulation_cfg.rst:15
msgid ""
"While we only cover the creation of an :class:`~assets.ArticulationCfg` in "
"this guide, the process is similar for creating any other asset "
"configuration object."
msgstr ""
"在本指南中，我们只涵盖了创建 :class:`~assets.ArticulationCfg` 的过程，但创建任何其他资产配置对象的过程类似。"

#: ../../source/how-to/write_articulation_cfg.rst:18
msgid ""
"We will use the Cartpole example to demonstrate how to create an "
":class:`~assets.ArticulationCfg`. The Cartpole is a simple robot that "
"consists of a cart with a pole attached to it. The cart is free to move "
"along a rail, and the pole is free to rotate about the cart. The file for "
"this configuration example is "
"``source/isaaclab_assets/isaaclab_assets/robots/cartpole.py``."
msgstr ""
"我们将使用Cartpole示例来演示如何创建 :class:`~assets.ArticulationCfg` 。 "
"Cartpole是一个简单的机器人，由一个连接到杆的小车组成。 小车可以沿着轨道自由移动，杆可以在小车周围自由旋转。该配置示例的文件为 "
"``source/isaaclab_assets/isaaclab_assets/robots/cartpole.py``."

#: ../../source/how-to/write_articulation_cfg.rst
msgid "Code for Cartpole configuration"
msgstr "Cartpole配置代码"

#: ../../source/how-to/write_articulation_cfg.rst:32
msgid "Defining the spawn configuration"
msgstr "定义生成配置"

#: ../../source/how-to/write_articulation_cfg.rst:34
msgid ""
"As explained in :ref:`tutorial-spawn-prims` tutorials, the spawn "
"configuration defines the properties of the assets to be spawned. This "
"spawning may happen procedurally, or through an existing asset file (e.g. "
"USD or URDF). In this example, we will spawn the Cartpole from a USD file."
msgstr ""
"如 :ref:`tutorial-spawn-prims` "
"教程中所述，生成配置定义要生成的资产的属性。此生成可能以程序方式进行，也可能通过现有的资产文件（例如USD或URDF）进行。在本例中，我们将从USD文件生成Cartpole。"

#: ../../source/how-to/write_articulation_cfg.rst:39
msgid ""
"When spawning an asset from a USD file, we define its "
":class:`~sim.spawners.from_files.UsdFileCfg`. This configuration object "
"takes in the following parameters:"
msgstr ""
"从USD文件生成资产时，我们定义其 :class:`~sim.spawners.from_files.UsdFileCfg` 。此配置对象接收以下参数:"
" "

#: ../../source/how-to/write_articulation_cfg.rst:42
msgid ""
":class:`~sim.spawners.from_files.UsdFileCfg.usd_path`: The USD file path to "
"spawn from"
msgstr ":class:`~sim.spawners.from_files.UsdFileCfg.usd_path`: 要生成的USD文件路径"

#: ../../source/how-to/write_articulation_cfg.rst:43
msgid ""
":class:`~sim.spawners.from_files.UsdFileCfg.rigid_props`: The properties of "
"the articulation's root"
msgstr ":class:`~sim.spawners.from_files.UsdFileCfg.rigid_props`: 关节根部的属性"

#: ../../source/how-to/write_articulation_cfg.rst:44
msgid ""
":class:`~sim.spawners.from_files.UsdFileCfg.articulation_props`: The "
"properties of all the articulation's links"
msgstr ""
":class:`~sim.spawners.from_files.UsdFileCfg.articulation_props`: 所有关节链接的属性"

#: ../../source/how-to/write_articulation_cfg.rst:46
msgid ""
"The last two parameters are optional. If not specified, they are kept at "
"their default values in the USD file."
msgstr "最后两个参数是可选的。如果未指定，它们将保持在USD文件中的默认值。"

#: ../../source/how-to/write_articulation_cfg.rst:53
msgid ""
"To import articulation from a URDF file instead of a USD file, you can "
"replace the :class:`~sim.spawners.from_files.UsdFileCfg` with a "
":class:`~sim.spawners.from_files.UrdfFileCfg`. For more details, please "
"check the API documentation."
msgstr ""
"如要从URDF文件中导入关节而不是从USD文件中导入，你可以用 "
":class:`~sim.spawners.from_files.UrdfFileCfg` 替换 "
":class:`~sim.spawners.from_files.UsdFileCfg` 。更多详情，请查看API文档。"

#: ../../source/how-to/write_articulation_cfg.rst:59
msgid "Defining the initial state"
msgstr "定义初始状态"

#: ../../source/how-to/write_articulation_cfg.rst:61
msgid ""
"Every asset requires defining their initial or *default* state in the "
"simulation through its configuration. This configuration is stored into the "
"asset's default state buffers that can be accessed when the asset's state "
"needs to be reset."
msgstr ""
"每个资产都需要通过其配置在仿真中定义其初始或 *默认* 状态。此配置存储在资产的默认状态缓冲区中，当需要重置资产状态时，可以访问这些缓冲区。"

#: ../../source/how-to/write_articulation_cfg.rst:66
msgid ""
"The initial state of an asset is defined w.r.t. its local environment frame."
" This then needs to be transformed into the global simulation frame when "
"resetting the asset's state. For more details, please check the "
":ref:`tutorial-interact-articulation` tutorial."
msgstr ""
"资产的初始状态是根据其本地环境框架定义的。然后，当重置资产状态时，需要将其转换为全局仿真框架。更多详情，请查看 :ref:`tutorial-"
"interact-articulation` 教程。"

#: ../../source/how-to/write_articulation_cfg.rst:71
msgid ""
"For an articulation, the :class:`~assets.ArticulationCfg.InitialStateCfg` "
"object defines the initial state of the root of the articulation and the "
"initial state of all its joints. In this example, we will spawn the Cartpole"
" at the origin of the XY plane at a Z height of 2.0 meters. Meanwhile, the "
"joint positions and velocities are set to 0.0."
msgstr ""
"对于关节， :class:`~assets.ArticulationCfg.InitialStateCfg` "
"对象定义了关节根部的初始状态以及所有关节的初始状态。在本例中，我们将在XY平面的原点处生成Cartpole，在Z高度为2.0米处。同时，关节位置和速度设置为0.0。"

#: ../../source/how-to/write_articulation_cfg.rst:82
msgid "Defining the actuator configuration"
msgstr "定义执行器配置"

#: ../../source/how-to/write_articulation_cfg.rst:84
msgid ""
"Actuators are a crucial component of an articulation. Through this "
"configuration, it is possible to define the type of actuator model to use. "
"We can use the internal actuator model provided by the physics engine (i.e. "
"the implicit actuator model), or use a custom actuator model which is "
"governed by a user-defined system of equations (i.e. the explicit actuator "
"model). For more details on actuators, see :ref:`overview-actuators`."
msgstr ""
"执行器是关节中的关键组件。通过此配置，可以定义要使用的执行器模型类型。我们可以使用物理引擎提供的内部执行器模型（即隐式执行器模型），也可以使用用户定义的方程系统控制的自定义执行器模型（即显式执行器模型）。有关执行器的更多详情，请参见"
" :ref:`overview-actuators` 。"

#: ../../source/how-to/write_articulation_cfg.rst:90
msgid ""
"The cartpole's articulation has two actuators, one corresponding to its each"
" joint: ``cart_to_pole`` and ``slider_to_cart``. We use two different "
"actuator models for these actuators as an example. However, since they are "
"both using the same actuator model, it is possible to combine them into a "
"single actuator model."
msgstr ""
"cartpole的关节具有两个执行器，分别对应于它的每个关节:``cart_to_pole`` 和 ``slider_to_cart`` "
"。我们对这些执行器使用两种不同的执行器模型作为示例。但是，由于它们都使用相同的执行器模型，可以将它们组合成一个单独的执行器模型。"

#: ../../source/how-to/write_articulation_cfg.rst
msgid "Actuator model configuration with separate actuator models"
msgstr "使用分开的执行器模型进行执行器模型配置"

#: ../../source/how-to/write_articulation_cfg.rst
msgid "Actuator model configuration with a single actuator model"
msgstr "使用单个执行器模型进行执行器模型配置"

#: ../../source/how-to/write_articulation_cfg.rst:121
msgid "ActuatorCfg velocity/effort limits considerations"
msgstr "ActuatorCfg 速度/力矩限制考虑"

#: ../../source/how-to/write_articulation_cfg.rst:123
msgid ""
"In IsaacLab v1.4.0, the plain ``velocity_limit`` and ``effort_limit`` "
"attributes were **not** consistently pushed into the physics solver:"
msgstr ""
"在 IsaacLab v1.4.0 中，普通的 ``velocity_limit`` 和 ``effort_limit`` 属性 **没有** "
"被一致地传入物理求解器中: "

#: ../../source/how-to/write_articulation_cfg.rst:126
msgid ""
"**Implicit actuators** - velocity_limit was ignored (never set in "
"simulation) - effort_limit was set into simulation"
msgstr "**隐式执行器** - 速度限制被忽略（在仿真中从未设置） - effort_limit 已设置到仿真中"

#: ../../source/how-to/write_articulation_cfg.rst:130
msgid ""
"**Explicit actuators** - both velocity_limit and effort_limit were used only"
" by the drive model, not by the solver"
msgstr "**显式执行器** - velocity_limit 和 effort_limit 仅由驱动模型使用，而不是由求解器使用"

#: ../../source/how-to/write_articulation_cfg.rst:134
msgid ""
"In v2.0.1 we accidentally changed this: all velocity_limit & effort_limit, "
"implicit or explicit, were being applied to the solver. That caused many "
"training under the old default uncaped solver limits to break."
msgstr ""
"在 v2.0.1 中，我们意外地更改了这一点: 所有 velocity_limit 和 effort_limit "
"，无论是隐式还是显式，都被应用到了求解器上。这导致许多在旧的默认无上限求解器限制下进行训练的任务出现问题。"

#: ../../source/how-to/write_articulation_cfg.rst:138
msgid ""
"To restore the original behavior while still giving users full control over "
"solver limits, we introduced two new flags:"
msgstr "为了恢复原始行为，同时仍然给用户完全控制求解器限制，我们引入了两个新标志: "

#: ../../source/how-to/write_articulation_cfg.rst:140
msgid ""
"**velocity_limit_sim** Sets the physics-solver's maximum joint-velocity cap "
"in simulation."
msgstr "**velocity_limit_sim** 设置物理求解器在仿真中的最大关节速度上限。"

#: ../../source/how-to/write_articulation_cfg.rst:143
msgid ""
"**effort_limit_sim** Sets the physics-solver's maximum joint-effort cap in "
"simulation."
msgstr "**effort_limit_sim** 设置仿真中物理求解器的最大关节力矩上限。"

#: ../../source/how-to/write_articulation_cfg.rst:147
msgid ""
"These explicitly set the solver's joint-velocity and joint-effort caps at "
"simulation level."
msgstr "这些明确定义了求解器在仿真级别上的关节速度和关节力矩的限制。"

#: ../../source/how-to/write_articulation_cfg.rst:149
msgid ""
"On the other hand, velocity_limit and effort_limit model the motor's "
"hardware-level constraints in torque computation for all explicit actuators "
"rather than limiting simulation-level constraint. For implicit actuators, "
"since they do not model motor hardware limitations, ``velocity_limit`` were "
"removed in v2.1.1 and marked as deprecated. This preserves same behavior as "
"they did in v1.4.0. Eventually, ``velocity_limit`` and ``effort_limit`` will"
" be deprecated for implicit actuators, preserving only "
"``velocity_limit_sim`` and ``effort_limit_sim``"
msgstr ""
"另一方面， velocity_limit 和 effort_limit "
"对所有显式执行器中的扭矩计算仿真了电机的硬件级约束，而不是限制仿真级约束。对于隐式执行器，由于它们不仿真电动机硬件限制，``velocity_limit``"
" 在 v2.1.1 版本中被移除，并标记为不推荐使用。这保持了与 v1.4.0 版本相同的行为。 "
"最终，对于隐式执行器，``velocity_limit`` 和 ``effort_limit`` 将被标记为不推荐使用，仅保留 "
"``velocity_limit_sim`` 和 ``effort_limit_sim`` 。"

#: ../../source/how-to/write_articulation_cfg.rst:157
msgid "Limit Options Comparison"
msgstr "限制选项比较"

#: ../../source/how-to/write_articulation_cfg.rst:163
msgid "**Attribute**"
msgstr "**属性**"

#: ../../source/how-to/write_articulation_cfg.rst:164
msgid "**Implicit Actuator**"
msgstr "隐式执行器"

#: ../../source/how-to/write_articulation_cfg.rst:165
msgid "**Explicit Actuator**"
msgstr "**显式执行器**"

#: ../../source/how-to/write_articulation_cfg.rst:166
msgid "``velocity_limit``"
msgstr "``velocity_limit``"

#: ../../source/how-to/write_articulation_cfg.rst:167
msgid "Deprecated (alias for ``velocity_limit_sim``)"
msgstr "已弃用（ ``velocity_limit_sim`` 的别名）"

#: ../../source/how-to/write_articulation_cfg.rst:168
msgid "Used by the model (e.g. DC motor), not set into simulation"
msgstr "被模型（例如直流电机）使用，未设置到仿真中"

#: ../../source/how-to/write_articulation_cfg.rst:169
msgid "``effort_limit``"
msgstr "``effort_limit``"

#: ../../source/how-to/write_articulation_cfg.rst:170
msgid "Deprecated (alias for ``effort_limit_sim``)"
msgstr "已弃用（ ``effort_limit_sim`` 的别名）"

#: ../../source/how-to/write_articulation_cfg.rst:171
msgid "Used by the model, not set into simulation"
msgstr "被模型使用，未设置到仿真中。"

#: ../../source/how-to/write_articulation_cfg.rst:172
msgid "``velocity_limit_sim``"
msgstr "``velocity_limit_sim``"

#: ../../source/how-to/write_articulation_cfg.rst:173
#: ../../source/how-to/write_articulation_cfg.rst:174
#: ../../source/how-to/write_articulation_cfg.rst:176
#: ../../source/how-to/write_articulation_cfg.rst:177
msgid "Set into simulation"
msgstr "设置到仿真中"

#: ../../source/how-to/write_articulation_cfg.rst:175
msgid "``effort_limit_sim``"
msgstr "``effort_limit_sim``"

#: ../../source/how-to/write_articulation_cfg.rst:181
msgid ""
"Users who want to tune the underlying physics-solver limits should set the "
"``_sim`` flags."
msgstr "想要调整基础物理求解器限制的用户应当设置 ``_sim`` 标志。"

#: ../../source/how-to/write_articulation_cfg.rst:185
msgid "USD vs. ActuatorCfg discrepancy resolution"
msgstr "USD vs. ActuatorCfg 差异解决"

#: ../../source/how-to/write_articulation_cfg.rst:187
msgid ""
"USD having default value and the fact that ActuatorCfg can be specified with"
" None, or a overriding value can sometime be confusing what exactly gets "
"written into simulation. The resolution follows these simple rules,per joint"
" and per property:"
msgstr ""
"USD 具有默认值，并且 ActuatorCfg 可以指定为 "
"None，或者有时会令人困惑的是覆盖值实际写入仿真中的规则。解决方案遵循这些简单规则，每个关节和每个属性:"

#: ../../source/how-to/write_articulation_cfg.rst:191
msgid "Resolution Rules for USD vs. ActuatorCfg"
msgstr "USD vs. ActuatorCfg 的分辨率规则"

#: ../../source/how-to/write_articulation_cfg.rst:194
msgid "**Condition**"
msgstr "**条件**"

#: ../../source/how-to/write_articulation_cfg.rst:194
msgid "**ActuatorCfg Value**"
msgstr "**驱动器配置值**"

#: ../../source/how-to/write_articulation_cfg.rst:194
msgid "**Applied**"
msgstr "**应用**"

#: ../../source/how-to/write_articulation_cfg.rst:196
msgid "No override provided"
msgstr "未提供覆盖"

#: ../../source/how-to/write_articulation_cfg.rst:196
msgid "Not Specified"
msgstr "未指定"

#: ../../source/how-to/write_articulation_cfg.rst:196
msgid "USD Value"
msgstr "USD Value"

#: ../../source/how-to/write_articulation_cfg.rst:198
msgid "Override provided"
msgstr "提供覆盖"

#: ../../source/how-to/write_articulation_cfg.rst:198
msgid "User's ActuatorCfg"
msgstr "用户的 ActuatorCfg"

#: ../../source/how-to/write_articulation_cfg.rst:198
msgid "Same as ActuatorCfg"
msgstr "与 ActuatorCfg 相同"

#: ../../source/how-to/write_articulation_cfg.rst:202
msgid ""
"Digging into USD can sometime be unconvinent, to help clarify what exact "
"value is written, we designed a flag "
":attr:`~isaaclab.assets.ArticulationCfg.actuator_value_resolution_debug_print`,"
" to help user figure out what exact value gets used in simulation."
msgstr ""
"深入研究 USD 有时可能是不方便的，为了帮助弄清所写的确切值，我们设计了一个标志:  "
":attr:`~isaaclab.assets.ArticulationCfg.actuator_value_resolution_debug_print`"
" ，以帮助用户弄清楚在仿真中使用了哪个确切值。"

#: ../../source/how-to/write_articulation_cfg.rst:206
msgid ""
"Whenever an actuator parameter is overridden in the user's ActuatorCfg (or "
"left unspecified), we compare it to the value read from the USD definition "
"and record any differences.  For each joint and each property, if unmatching"
" value is found, we log the resolution:"
msgstr ""
"每当在用户的 "
"ActuatorCfg（或未指定）中覆盖执行器参数时，我们将其与从USD定义中读取的值进行比较，并记录任何差异。对于每个关节和每个属性，如果找到不匹配的值，我们记录下解决方案:"
" "

#: ../../source/how-to/write_articulation_cfg.rst:210
msgid "**USD Value** The default limit or gain parsed from the USD asset."
msgstr "**USD 值** USD资产解析的默认限制或增益。"

#: ../../source/how-to/write_articulation_cfg.rst:213
msgid ""
"**ActuatorCfg Value** The user-provided override (or “Not Specified” if none"
" was given)."
msgstr "**ActuatorCfg 值** 用户提供的覆盖值（如果没有提供则为 “未指定” ）。"

#: ../../source/how-to/write_articulation_cfg.rst:216
msgid ""
"**Applied** The final value actually used for simulation: if the user didn't"
" override it, this matches the USD value; otherwise it reflects the user's "
"setting."
msgstr "**应用** 实际用于仿真的最终数值: 如果用户没有覆盖它，这将与USD值匹配；否则，它将反映用户的设置。"

#: ../../source/how-to/write_articulation_cfg.rst:220
msgid ""
"This resolution info is emitted as a warning table only when discrepancies "
"exist. Here's an example of what you'll see::"
msgstr "此解决方案信息仅在存在差异时作为警告表格发出。以下是您将看到的示例: "

#: ../../source/how-to/write_articulation_cfg.rst:267
msgid ""
"To keep the cleaniness of logging, "
":attr:`~isaaclab.assets.ArticulationCfg.actuator_value_resolution_debug_print`"
" default to False, remember to turn it on when wishes."
msgstr ""
"为保持日志的清晰， "
":attr:`~isaaclab.assets.ArticulationCfg.actuator_value_resolution_debug_print`"
" 默认为 False，请在需要时记得将其打开。"
