# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022-2025, The Isaac Lab Project Developers.
# This file is distributed under the same license as the Isaac Lab package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Isaac Lab 2.2.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 09:49+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Ziqi Fan <fanziqi614@gmail.com>\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Generated-By: Babel 2.17.0\n"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:4
msgid "Interacting with a surface gripper"
msgstr "与表面夹爪互动"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:9
msgid ""
"This tutorial shows how to interact with an articulated robot with a surface"
" gripper attached to its end-effector in the simulation. It is a "
"continuation of the :ref:`tutorial-interact-articulation` tutorial, where we"
" learned how to interact with an articulated robot. Note that as of IsaacSim"
" 5.0 the surface gripper are only supported on the cpu backend."
msgstr ""
"本教程展示了如何在仿真中与连接到其末端执行器的关节机器人进行交互。这是 :ref:`tutorial-interact-articulation` "
"教程的延续，我们在那里学习了如何与关节机器人进行交互。请注意，截至 IsaacSim 5.0，仅支持在cpu后端上的表面夹爪。"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:16
msgid "The Code"
msgstr "代码"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:18
msgid ""
"The tutorial corresponds to the ``run_surface_gripper.py`` script in the "
"``scripts/tutorials/01_assets`` directory."
msgstr ""
"该教程对应于 ``scripts/tutorials/01_assets`` 目录中的 ``run_surface_gripper.py`` 脚本。"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst
msgid "Code for run_surface_gripper.py"
msgstr "run_surface_gripper.py 的代码"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:31
msgid "The Code Explained"
msgstr "代码解释"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:34
msgid "Designing the scene"
msgstr "设计场景"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:36
msgid ""
"Similarly to the previous tutorial, we populate the scene with a ground "
"plane and a distant light. Then, we spawn an articulation from its USD file."
" This time a pick-and-place robot is spawned. The pick-and-place robot is a "
"simple robot with 3 driven axes, its gantry allows it to move along the x "
"and y axes, as well as up and down along the z-axis. Furthermore, the robot "
"end-effector is outfitted with a surface gripper. The USD file for the pick-"
"and-place robot contains the robot's geometry, joints, and other physical "
"properties as well as the surface gripper. Before implementing a similar "
"gripper on your own robot, we recommend to check out the USD file for the "
"gripper found on Isaaclab's Nucleus."
msgstr ""
"类似于上一个教程，我们在场景中添加了地面平面和一个远处的光源。然后，我们从其 USD 文件中生成一个关节。这次生成了一个拾取-放置机器人。拾取-"
"放置机器人是一个简单的机器人，有 3 个受驱动的轴，其龙门使其可以沿 x 和 y 轴移动，以及沿 z "
"轴上下移动。此外，机器人末端执行器配备了一个表面夹爪。拾取放置机器人的 USD "
"文件包含了机器人的几何形状、关节和其他物理属性以及表面夹爪。在自己的机器人上实现类似的夹爪之前，我们建议查看 Isaaclab 的 Nucleus "
"上找到的夹爪的 USD 文件。"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:44
msgid ""
"For the pick-and-place robot, we use its pre-defined configuration object, "
"you can find out more about it in the :ref:`how-to-write-articulation-"
"config` tutorial. For the surface gripper, we also need to create a "
"configuration object. This is done by instantiating a "
":class:`assets.SurfaceGripperCfg` object and passing it the relevant "
"parameters."
msgstr ""
"对于抓取和放置机器人，我们使用它的预定义配置对象，在 :ref:`how-to-write-articulation-config` "
"教程中可以找到更多信息。对于表面夹爪，我们还需要创建一个配置对象。这可以通过实例化一个 "
":class:`assets.SurfaceGripperCfg` 对象并传递相关参数来实现。"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:49
msgid "The available parameters are:"
msgstr "可用的参数包括: "

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:51
msgid ""
"``max_grip_distance``: The maximum distance at which the gripper can grasp "
"an object."
msgstr "``max_grip_distance``: 夹爪能够抓取物体的最大距离。"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:52
msgid ""
"``shear_force_limit``: The maximum force the gripper can exert in the "
"direction perpendicular to the gripper's axis."
msgstr "``shear_force_limit``: 夹爪能在与夹爪轴线垂直的方向上施加的最大力。"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:53
msgid ""
"``coaxial_force_limit``: The maximum force the gripper can exert in the "
"direction of the gripper's axis."
msgstr "``coaxial_force_limit``: 夹爪沿夹爪轴的方向可以施加的最大力。"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:54
msgid ""
"``retry_interval``: The time the gripper will stay in a grasping state."
msgstr "``retry_interval``: 夹爪将保持在抓取状态的时间。"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:56
msgid ""
"As seen in the previous tutorial, we can spawn the articulation into the "
"scene in a similar fashion by creating an instance of the "
":class:`assets.Articulation` class by passing the configuration object to "
"its constructor. The same principle applies to the surface gripper. By "
"passing the configuration object to the :class:`assets.SurfaceGripper` "
"constructor, the surface gripper is created and can be added to the scene. "
"In practice, the object will only be initialized when the play button is "
"pressed."
msgstr ""
"如前面的教程中所见，我们可以通过创建一个 :class:`assets.Articulation` "
"类的实例，并将配置对象传递给其构造函数，以类似的方式将关节添加到场景中。同样的原则也适用于表面夹爪。通过将配置对象传递给 "
":class:`assets.SurfaceGripper` "
"构造函数，就可以创建表面夹爪并将其添加到场景中。实际上，当按下播放按钮时，对象将只被初始化。"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:69
msgid "Running the simulation loop"
msgstr "运行仿真循环"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:71
msgid ""
"Continuing from the previous tutorial, we reset the simulation at regular "
"intervals, set commands to the articulation, step the simulation, and update"
" the articulation's internal buffers."
msgstr "继续从前一教程开始，我们定期重置仿真，为关节设置指令，执行仿真步骤，并更新关节的内部缓冲区。"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:75
msgid "Resetting the simulation"
msgstr "重置仿真"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:77
msgid ""
"To reset the surface gripper, we only need to call the "
":meth:`SurfaceGripper.reset` method which will reset the internal buffers "
"and caches."
msgstr "要重置表面夹爪，我们只需要调用 `:meth:`SurfaceGripper.reset` 方法，这将重置内部缓冲区和缓存。"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:86
msgid "Stepping the simulation"
msgstr "步进仿真"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:88
msgid "Applying commands to the surface gripper involves two steps:"
msgstr "将命令应用到表面夹爪涉及两个步骤: "

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:90
msgid ""
"*Setting the desired commands*: This sets the desired gripper commands "
"(Open, Close, or Idle)."
msgstr "*设置所需命令*: 这将设置所需的夹爪命令（打开、关闭或空闲）。"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:91
msgid ""
"*Writing the data to the simulation*: Based on the surface gripper's "
"configuration, this step handles writes the converted values to the PhysX "
"buffer."
msgstr "*将数据写入仿真*: 基于表面夹爪的配置，此步骤将转换后的值写入PhysX缓冲区。"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:94
msgid ""
"In this tutorial, we use a random command to set the gripper's command. The "
"gripper behavior is as follows:"
msgstr "在本教程中，我们使用一个随机命令来设置夹爪的指令。夹爪的行为如下: "

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:96
msgid "-1 < command < -0.3 --> Gripper is Opening"
msgstr "-1 < command < -0.3 --> 夹爪打开中"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:97
msgid "-0.3 < command < 0.3 --> Gripper is Idle"
msgstr "-0.3 < command < 0.3` --> 夹爪空闲中"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:98
msgid "0.3 < command < 1 --> Gripper is Closing"
msgstr "0.3 < command < 1 --> 夹爪关闭中"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:100
msgid ""
"At every step, we randomly sample commands and set them to the gripper by "
"calling the :meth:`SurfaceGripper.set_grippers_command` method. After "
"setting the commands, we call the :meth:`SurfaceGripper.write_data_to_sim` "
"method to write the data to the PhysX buffer. Finally, we step the "
"simulation."
msgstr ""
"在每一步中，我们通过调用 :meth:`SurfaceGripper.set_grippers_command` "
"方法随机采样命令并将其设置到夹爪中。设置完命令后，我们调用 :meth:`SurfaceGripper.write_data_to_sim` "
"方法将数据写入到PhysX缓冲区中。最后，我们进行仿真步进。"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:112
msgid "Updating the state"
msgstr "更新状态"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:114
msgid ""
"To know the current state of the surface gripper, we can query the "
":meth:`assets.SurfaceGripper.state` property. This property returns a tensor"
" of size ``[num_envs]`` where each element is either ``-1``, ``0``, or ``1``"
" corresponding to the gripper state. This property is updated every time the"
" :meth:`assets.SurfaceGripper.update` method is called."
msgstr ""
"要了解表面夹爪的当前状态，我们可以查询 :meth:`assets.SurfaceGripper.state` 属性。这个属性返回一个大小为 "
"``[num_envs]`` 的张量，其中每个元素都是 ``-1`` 、 ``0`` 或 ``1`` ，分别对应夹爪的状态。这个属性在每次调用 "
":meth:`assets.SurfaceGripper.update` 方法时都会更新。"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:119
msgid "``-1`` --> Gripper is Open"
msgstr "``-1`` --> 机械手爪是打开的"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:120
msgid "``0`` --> Gripper is Closing"
msgstr "``0`` --> 夹爪正在闭合"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:121
msgid "``1`` --> Gripper is Closed"
msgstr "``1`` --> 夹爪已关闭"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:130
msgid "The Code Execution"
msgstr "代码执行"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:133
msgid ""
"To run the code and see the results, let's run the script from the terminal:"
msgstr "要运行代码并查看结果，请从终端运行脚本: "

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:140
msgid ""
"This command should open a stage with a ground plane, lights, and two pick-"
"and-place robots. In the terminal, you should see the gripper state and the "
"command being printed. To stop the simulation, you can either close the "
"window, or press ``Ctrl+C`` in the terminal."
msgstr ""
"这个命令应该打开一个带有地面平面、灯光和两个夹取放置机器人的场景。在终端中，您应该看到夹爪的状态以及打印出的命令。要停止仿真，您可以关闭窗口，或在终端中按"
" ``Ctrl+C`` 。"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:-1
msgid "result of run_surface_gripper.py"
msgstr "run_surface_gripper.py 的结果"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:149
msgid ""
"In this tutorial, we learned how to create and interact with a surface "
"gripper. We saw how to set commands and query the gripper state. We also saw"
" how to update its buffers to read the latest state from the simulation."
msgstr ""
"在本教程中，我们学习了如何创建和与表面夹爪进行交互。我们看到如何设置命令并查询夹爪的状态。我们还看到如何更新其缓冲区以从仿真中读取最新状态。"

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:152
msgid ""
"In addition to this tutorial, we also provide a few other scripts that spawn"
" different robots. These are included in the ``scripts/demos`` directory. "
"You can run these scripts as:"
msgstr ""
"除了本教程之外，我们还提供了一些生成不同机器人的其他脚本。这些脚本包含在 ``scripts/demos`` 目录中。您可以这样运行这些脚本: "

#: ../../source/tutorials/01_assets/run_surface_gripper.rst:160
msgid ""
"Note that in practice, the users would be expected to register their "
":class:`assets.SurfaceGripper` instances inside a "
":class:`isaaclab.InteractiveScene` object, which will automatically handle "
"the calls to the :meth:`assets.SurfaceGripper.write_data_to_sim` and "
":meth:`assets.SurfaceGripper.update` methods."
msgstr ""
"请注意，实践中，用户应该将他们的 `assets.SurfaceGripper` 实例注册到 `isaaclab.InteractiveScene` "
"对象中，在那里会自动处理对 `assets.SurfaceGripper.write_data_to_sim` 和 "
"`assets.SurfaceGripper.update` 方法的调用。"
