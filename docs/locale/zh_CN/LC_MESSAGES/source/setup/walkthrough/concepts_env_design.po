# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022-2025, The Isaac Lab Project Developers.
# This file is distributed under the same license as the Isaac Lab package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
msgid ""
msgstr ""
"Project-Id-Version: Isaac Lab 2.1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-30 10:41+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Ziqi Fan <fanziqi614@gmail.com>\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Generated-By: Babel 2.17.0\n"

#: ../../source/setup/walkthrough/concepts_env_design.rst:4
msgid "Environment Design Background"
msgstr "环境设计背景"

#: ../../source/setup/walkthrough/concepts_env_design.rst:6
msgid ""
"Now that we have our project installed, we can start designing the "
"environment. In the traditional description of a reinforcement learning (RL)"
" problem, the environment is responsible for using the actions produced by "
"the agent to update the state of the \"world\", and finally compute and "
"return the observations and the reward signal. However, there are some "
"additional concepts that are unique to Isaac Sim and Lab regarding the "
"mechanics of the simulation itself. The traditional description of a "
"reinforcement learning problem presumes a \"world\", but we get no such "
"luxury; we must define the world ourselves, and success depends on "
"understanding on how to construct that world and how it will fit into the "
"simulation."
msgstr ""
"现在我们已经安装好项目，可以开始设计环境了。在传统的强化学习（RL）问题描述中，环境负责使用智能体生成的动作来更新 \"世界\" "
"的状态，最终计算并返回观测值和奖励信号。然而，关于仿真机制本身，Isaac Sim 和 Lab 有一些独特的概念。传统的强化学习问题描述设定了一个 "
"\"世界\" ，但我们却没有这样的奢侈品，我们必须自己定义这个世界，成功与否取决于理解如何构建这个世界以及它如何适应仿真。"

#: ../../source/setup/walkthrough/concepts_env_design.rst:14
msgid "App, Sim, World, Stage, and Scene"
msgstr "App、Sim、World、Stage 和 Scene"

#: ../../source/setup/walkthrough/concepts_env_design.rst:-1
msgid "How the sim is organized."
msgstr "sim 的组织方式。"

#: ../../source/setup/walkthrough/concepts_env_design.rst:21
msgid ""
"The **World** is defined by the origin of a cartesian coordinate system and "
"the units that define it. How big or how small? How near or how far?  The "
"answers to questions like these can only be defined *relative* to some "
"contextual reference frame, and that reference frame is what defines the "
"world."
msgstr ""
"**World** 是由笛卡尔坐标系的原点和定义它的单位所定义的。有多大或多小？离得多近或多远？ "
"对这些问题的答案只能相对于某种上下文的参考框架来定义，而这个参考框架就是定义世界的。"

#: ../../source/setup/walkthrough/concepts_env_design.rst:25
msgid ""
"\"Above\" the world in structure is the **Sim**\\ ulation and the **App**\\ "
"lication.  The **Application** is \"the thing responsible for everything "
"else\": It governs all resource management as well as launching and "
"destroying the simulation when we are done with it. When we :ref:`launched "
"training with the template<template-generator>`, the window that appears "
"with the viewport of cartpoles training is the Application window.  The "
"application is not defined by the GUI however, and even when running in "
"headless mode all simulations have an application that governs them."
msgstr ""
"结构上，world \"上方\" 是 **Sim**\\ ulation 和 **App**\\ lication 。 **Application** "
"是 \"负责其他一切的东西\" : 它控制所有资源管理以及在我们完成后启动和销毁仿真。当我们 :ref:`用模板进行训练启动<template-"
"generator>` 时，出现的窗口与用来训练 cartpoles 的视口是 Application 窗口。但是，Application 不是由 "
"GUI 定义的，即使在headless模式下运行，所有仿真都有一个控制它们的 application。"

#: ../../source/setup/walkthrough/concepts_env_design.rst:31
msgid ""
"The **Simulation** controls the \"rules\" of the world.  It defines the laws"
" of physics, such as how time and gravity should work, and how frequently to"
" perform rendering. If the application holds the sim, then the sim holds the"
" world. The simulation governs a single step through time by dividing it "
"into many different sub-steps, each devoted to a specific aspect of updating"
" the world into a state. Many of the APIs in Isaac Lab are written to "
"specifically hook into these various steps and you will often see functions "
"named like ``_pre_XYZ_step`` and ``_post_XYZ_step`` where ``XYZ_step`` is "
"the name of one of these sub-steps of the simulation, such as the "
"``physics_step`` or the ``render_step``."
msgstr ""
"**Simulation** 控制着世界的 \"规则\" 。它定义物理法则，比如时间和重力如何工作，以及频率如何执行渲染。如果 application "
"持有 sim，那么 sim 就持有世界。Simulation 通过将时间划分为许多不同的子步骤，每个步骤都致力于更新世界到一个状态。Isaac Lab "
"中的许多 API 是专门为了连接到这些不同步骤而编写的，你经常会看到类似 ``_pre_XYZ_step`` 和 ``_post_XYZ_step`` "
"的命名函数，其中 ``XYZ_step`` 是仿真的一个子步骤的名称，比如 ``physics_step`` 或 ``render_step`` 。"

#: ../../source/setup/walkthrough/concepts_env_design.rst:37
msgid ""
"\"Below\" the world in structure is the **Stage** and the **Scene**.  If the"
" world provides spatial context to the sim, then the **Stage** provides the "
"*compositional context* for the world. Suppose we want to simulate a table "
"set for a meal in a room: the room is the \"world\" in this case, and we "
"choose the origin of the world to be one of the corners of the room. The "
"position of the table in the room is defined as a vector from the origin of "
"the world to some point on the table that we choose to be the origin of a "
"*new* coordinate system, fixed to the table.  It's not useful to us, *the "
"agent*\\ , to talk about the location of the food and the utensils on the "
"table with respect to the corner of the room: instead it is preferable to "
"use the coordinates defined with respect to the table. However, the "
"simulation needs to know these global coordinates in order to properly "
"simulate the next time step, so we must define how these two coordinate "
"systems are *composed* together."
msgstr ""
"结构上，world \"下方\" 是 **Stage** 和 **Scene** 。如果世界为仿真提供了空间上下文，那么 **Stage** "
"为世界提供了 *组成上下文* 。假设我们想在房间里仿真一张摆好了餐具的餐桌: 在这种情况下，房间就是 \"世界\" "
"，我们将世界的原点选为房间的一个角落。餐桌在房间里的位置被定义为从世界原点到我们选择的餐桌上的某个点的向量，我们将这个点选为固定在桌子上的一个 *新* "
"坐标系的原点。对我们 *智能体*\\ "
"来说，与其根据房间的角落谈论食物和餐具在餐桌上的位置，不如更喜欢使用相对于餐桌定义的坐标。然而，仿真需要知道这些全局坐标，以便正确地仿真下一个时间步，因此我们必须定义如何将这两个坐标系统"
" *组合* 在一起。"

#: ../../source/setup/walkthrough/concepts_env_design.rst:45
msgid ""
"This is what the stage accomplishes: everything in the simulation is a `USD "
"primitive <https://openusd.org/release/glossary.html#usdglossary-prim>`_ and"
" the stage represents the relationships between these primitives as a tree, "
"with the context being defined by the relative path in the tree. Every prim "
"on the stage has a name and therefore a path in this tree, such as "
"``/room/table/food`` or ``room/table/utensils``. Relationships are defined "
"by the \"parents\" and \"children\" of a given node in this tree: the "
"``table`` is a child of the ``room`` but a parent of ``food``. Compositional"
" properties of the parent are applied to all of its children, but child "
"prims have the ability to override parent properties if necessary, as is "
"often the case for materials."
msgstr ""
"这就是 Stage 的作用: 仿真中的每一个对象都是一个 `USD "
"原语<https://openusd.org/release/glossary.html#usdglossary-prim>`_ ，而 Stage "
"则将这些原语之间的关系表示为一棵树，上下文由树中的相对路径来定义。场景上的每个原语都有一个名称，因此在这棵树上有一个路径，例如 "
"``/room/table/food`` 或 ``room/table/utensils`` 。关系由这棵树中给定节点的 \"父节点\" 和 "
"\"子节点\" 来定义: ``table`` 是 ``room``的子节点，但是是 ``food`` "
"的父节点。父原语的组成属性应用于其所有子节点，但是子原语有能力在必要时覆盖父属性，这在材料的情况下经常发生。"

#: ../../source/setup/walkthrough/concepts_env_design.rst:-1
msgid "How the stage organizes context"
msgstr "Stage 如何组织上下文"

#: ../../source/setup/walkthrough/concepts_env_design.rst:56
msgid ""
"Armed with this vocabulary, we can finally talk about the **Scene**, one of "
"the most critical elements to understand about Isaac Lab. Deep learning, in "
"all its forms, is rooted in the analysis of data.  This is true even in "
"robot learning, where data is acquired through the sensors of the robot "
"being trained. The time required to setup the robot, collect data, and reset"
" the robot to collect more, is a fundamental bottleneck in teaching robots "
"to do *anything*, with any method. Isaac Sim gives us access to robots "
"without the need for literal physical robots, but Isaac Lab gives us access "
"to *vectorization*: the ability to simulate many copies of a training "
"procedure efficiently, thus multiplying the rate of data generation and "
"accelerating training proportionally. The scene governs those primitives on "
"the stage that matter to this vectorization process, known as **simulation "
"entities**."
msgstr ""
"有了这些词汇，我们终于可以谈论 Isaac Lab 中最关键的元素之一 **Scene** "
"了。深度学习，在各种形式中，都源于数据的分析。即使在机器学习中，数据是通过受训机器人的传感器获取的。设置机器人、收集数据并重置机器人以收集更多数据所需的时间，是教机器人做"
" *任何事情* 的基本瓶颈，无论使用什么方法。Isaac Sim 让我们可以访问机器人而无需实际的物理机器人，而 Isaac Lab 则给我们提供了 "
"*向量化* 的能力: 有效地仿真训练过程的多个副本，从而提高数据生成速度，加速按比例训练。场景管理了场景上对这个向量化过程有影响的那些原语，被称为 "
"**simulation entities** 。"

#: ../../source/setup/walkthrough/concepts_env_design.rst:63
msgid ""
"Suppose the reason why you want to simulate a table set for a meal is "
"because you would like to train a robot to place the table settings for you!"
" The robot, the table, and all the things on it can be registered to the "
"scene of an environment.  We can then specify how many copies we want and "
"the scene will automatically construct and run those copies on the stage. "
"These copies are placed at new coordinates on the stage, defining a new "
"reference frame from which observations and rewards can be computed. Every "
"copy of the scene exists on the stage and is being simulated by the same "
"world.  This is much more efficient than running unique simulations for each"
" copy, but it does open up the possibility of unwanted interactions between "
"copies of the scene, so it's important to keep this in mind while debugging."
msgstr ""
"假设你想仿真一张摆好了餐具的餐桌，是因为你想训练一个机器人来为你摆餐具！机器人、桌子以及桌子上的所有物品都可以注册到环境的场景中。我们可以指定要创建多少个副本，场景将自动构建并在场景上运行这些副本。这些副本被放置在场景上的新坐标上，定义了一个新的参考框架，从中观测和奖励可以被计算。场景中的每个副本都存在于场景上，并且由同一个世界进行仿真。这比为每个副本运行单独的仿真要高效得多，但同时也会带来不同副本之间意外交互的可能性，因此在调试时要牢记这一点。"

#: ../../source/setup/walkthrough/concepts_env_design.rst:70
msgid ""
"Now that we have a grasp on the mechanics, we can take a look at the code "
"generated for our template project!"
msgstr "现在我们对机制有了掌握，可以看一下为我们的模板项目生成的代码！"
