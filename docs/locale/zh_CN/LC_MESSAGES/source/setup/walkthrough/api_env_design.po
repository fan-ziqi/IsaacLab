# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022-2025, The Isaac Lab Project Developers.
# This file is distributed under the same license as the Isaac Lab package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
msgid ""
msgstr ""
"Project-Id-Version: Isaac Lab 2.1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-14 10:59+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Ziqi Fan <fanziqi614@gmail.com>\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Generated-By: Babel 2.17.0\n"

#: ../../source/setup/walkthrough/api_env_design.rst:4
msgid "Classes and Configs"
msgstr "类和配置"

#: ../../source/setup/walkthrough/api_env_design.rst:6
msgid ""
"To begin, navigate to the task: "
"``source/isaac_lab_tutorial/isaac_lab_tutorial/tasks/direct/isaac_lab_tutorial``,"
" and take a look and the contents of ``isaac_lab_tutorial_env_cfg.py``.  You"
" should see something that looks like the following"
msgstr ""
"要开始，请导航到任务: "
"``source/isaac_lab_tutorial/isaac_lab_tutorial/tasks/direct/isaac_lab_tutorial``"
" ，查看 ``isaac_lab_tutorial_env_cfg.py`` 的内容。您应该看到以下内容"

#: ../../source/setup/walkthrough/api_env_design.rst:42
msgid ""
"This is the default configuration for a simple cartpole environment that "
"comes with the template and defines the ``self`` scope for anything you do "
"within the corresponding environment."
msgstr "这是一个简单的倒立摆环境的默认配置，与模板一起提供，并定义了对应环境中任何操作的 ``self`` 作用域。"

#: ../../source/setup/walkthrough/api_env_design.rst:47
msgid ""
"The first thing to note is the presence of the ``@configclass`` decorator. "
"This defines a class as a configuration class, which holds a special place "
"in Isaac Lab. Configuration classes are part of how Isaac Lab determines "
"what to \"care\" about when it comes to cloning the environment to scale up "
"training. Isaac Lab provides different base configuration classes depending "
"on your goals, and in this case we are using the :class:`DirectRLEnvCfg` "
"class because we are interested in performing reinforcement learning in the "
"direct workflow."
msgstr ""
"首先要注意的是 ``@configclass`` 装饰器的存在。这将一个类定义为配置类，在 Isaac Lab 中具有特殊功能。根据您的目标，Isaac"
" Lab 提供不同的基本配置类，而在这种情况下，我们使用 :class:`DirectRLEnvCfg` "
"类，因为我们对在直接工作流中执行强化学习感兴趣。"

#: ../../source/setup/walkthrough/api_env_design.rst:54
msgid ""
"The second thing to note is the content of the configuration class. As the "
"author, you can specify any fields you desire but, generally speaking, there"
" are three things you will always define here: The **sim**, the **scene**, "
"and the **robot**. Notice that these fields are also configuration classes! "
"Configuration classes are compositional in this way as a solution for "
"cloning arbitrarily complex environments."
msgstr ""
"其次要注意的是配置类的内容。作为作者，您可以指定任何您希望定义的字段，但通常来说，您总是会在此处定义三件事: **sim** 、 **scene** 和"
" **robot** 。请注意，这些字段也是配置类！这种配置类的组合方式是解决克隆任意复杂环境的方案之一。"

#: ../../source/setup/walkthrough/api_env_design.rst:58
msgid ""
"The **sim** is an instance of :class:`SimulationCfg`, and this is the config"
" that controls the nature of the simulated reality we are building. This "
"field is a member of the base class, ``DirecRLEnvCfg``, but has a default "
"sim configuration, so it's *technically* optional.   The ``SimulationCfg`` "
"dictates how finely to step through time (dt), the direction of gravity, and"
" even how physics should be simulated. In this case we only specify the time"
" step and the render interval, with the former indicating that each step "
"through time should simulate :math:`1/120`th of a second, and the latter "
"being how many steps we should take before we render a frame (a value of 2 "
"means render every other frame)."
msgstr ""
"**sim** 是 :class:`SimulationCfg` 的一个实例，这是控制我们正在构建的模拟现实性质的配置。这个字段是基类 "
"``DirecRLEnvCfg`` 的成员，但具有默认的模拟配置，因此 *从技术上讲* 它是可选的。 ``SimulationCfg`` "
"决定了时间步长（dt）的精度，重力的方向，甚至是如何模拟物理。在这种情况下，我们仅指定时间步长和渲染间隔，前者指示每个时间步长模拟 "
":math:`1/120` 秒，后者是我们在渲染一帧之前应该采取的步骤数量（值为2表示每隔一帧渲染一次）。"

#: ../../source/setup/walkthrough/api_env_design.rst:66
msgid ""
"The **scene** is an instance of :class:`InteractiveSceneCfg`. The scene "
"describes what goes \"on the stage\" and manages those simulation entities "
"to be cloned across environments. The scene is also a member of the base "
"class ``DirectRLEnvCfg``, but unlike the sim it has no default and must be "
"defined in every ``DirectRLEnvCfg``.  The ``InteractiveSceneCfg`` describes "
"how many copies of the scene we want to create for training purposes, as "
"well as how far apart they should be spaced on the stage."
msgstr ""
"**scene** 是 :class:`InteractiveSceneCfg` "
"的一个实例。场景描述了舞台上发生的事情，并管理要在各个环境中复制的模拟实体。场景也是基类 ``DirectRLEnvCfg`` 的成员，但与 sim "
"不同，它没有默认值，必须在每一个 ``DirectRLEnvCfg`` 中定义。 ``InteractiveSceneCfg`` "
"描述了我们想要为训练创建多少个场景的副本，以及它们在舞台上应该被分隔多远。"

#: ../../source/setup/walkthrough/api_env_design.rst:72
msgid ""
"Finally we have the **robot** definition, which is an instance of  "
":class:`ArticulationCfg`. An environment could have multiple articulations, "
"and so the presence of an ``ArticulationCfg`` is not strictly required in "
"order to define a ``DirectRLEnv``.  Instead, the usual workflow is to define"
" a regex path to the robot, and replace the ``prim_path`` attribute in the "
"base configuration. In this case, ``CARTPOLE_CFG`` is a configuration "
"defined in ``isaaclab_assets.robots.cartpole`` and by replacing the prim "
"path with ``/World/envs/env_.*/Robot`` we are implicitly saying that every "
"copy of the scene will have a robot named ``Robot``."
msgstr ""
"最后，我们有 **robot** 的定义，它是 :class:`ArticulationCfg` 的一个实例。一个环境可能有多个关节，因此不严格要求存在"
" ``ArticulationCfg`` 来定义 ``DirectRLEnv`` "
"。相反，通常的工作流程是为机器人定义一个正则表达式路径，并在基本配置中替换 ``prim_path`` 属性。在这种情况下， "
"``CARTPOLE_CFG`` 是在 ``isaaclab_assets.robots.cartpole`` 中定义的配置，通过用 "
"``/World/envs/env_.*/Robot`` 替换 prim 路径，我们在暗示舞台上的每个场景都有一个名为 ``Robot`` 的机器人。"

#: ../../source/setup/walkthrough/api_env_design.rst:79
msgid "The Environment"
msgstr "环境"

#: ../../source/setup/walkthrough/api_env_design.rst:81
msgid ""
"Next, let's take a look at the contents of the other python file in our task"
" directory: ``isaac_lab_tutorial_env_cfg.py``"
msgstr "接下来，让我们看看我们任务目录中的另一个 python 文件的内容: ``isaac_lab_tutorial_env_cfg.py``"

#: ../../source/setup/walkthrough/api_env_design.rst:137
msgid ""
"Some of the code has been omitted for clarity, in order to aid in "
"discussion. This is where the actual \"meat\" of the direct workflow exists "
"and where most of our modifications will take place as we tweak the template"
" to suit our needs. Currently, all of the member functions of "
"``IsaacLabTutorialEnv`` are directly inherited from the "
":class:`DirectRLEnv`. This known interface is how Isaac Lab and its "
"supported RL frameworks interact with the environment."
msgstr ""
"为了便于讨论，某些代码已被省略。这是直接工作流的实际 \"核心\" 存在之处，我们会在此处进行大部分修改以调整模板以满足我们的需求。当前， "
"``IsaacLabTutorialEnv`` 的所有成员函数都直接从 :class:`DirectRLEnv` 继承。这个已知接口是 Isaac "
"Lab 及其支持的 RL 框架与环境交互的方式。"

#: ../../source/setup/walkthrough/api_env_design.rst:142
msgid ""
"When the environment is initialized, it receives its own config as an "
"argument, which is then immediately passed to super in order to initialize "
"the ``DirectRLEnv``.  This super call also calls ``_setup_scene``, which "
"actually constructs the scene and clones it appropriately. Notably is how "
"the robot is created and registered to the scene in ``_setup_scene``.  "
"First, the robot articulation is created by using the ``robot_config`` we "
"defined in ``IsaacLabTutorialEnvCfg``: it doesn't exist before this point! "
"When the articulation is created, the robot exists on the stage at "
"``/World/envs/env_0/Robot``.  The call to ``scene.clone_environments`` then "
"copies ``env_0`` appropriately.  At this point the robot exists as many "
"copies on the stage, so all that's left is to notify the ``scene`` object of"
" the existence of this articulation to be tracked.  The articulations of the"
" scene are kept as a dictionary, so ``scene.articulations[\"robot\"] = "
"self.robot`` creates a new ``robot`` element of the ``articulations`` "
"dictionary and sets the value to be ``self.robot``."
msgstr ""
"当环境初始化时，它接收到自己的配置作为参数，然后立即传递给 super，以初始化 ``DirectRLEnv`` 。这个 super 调用还调用 "
"``_setup_scene`` ，它实际上构建了场景并适当地克隆了它。值得注意的是如何在 ``_setup_scene`` "
"中创建机器人并将其注册到场景中。首先，通过使用我们在 ``IsaacLabTutorialEnvCfg`` 中定义的 ``robot_config`` "
"创建机器人关节: 在此之前，它是不存在的！当关节创建时，机器人存在于舞台上的 ``/World/envs/env_0/Robot`` 处。然后调用 "
"``scene.clone_environments`` 适当地复制了 ``env_0`` "
"。此时，机器人作为多个副本存在于舞台上，所以唯一剩下的就是通知 ``scene`` 对象这个关节的存在以进行跟踪。场景的关节被保存为一个字典，因此 "
"``scene.articulations[\"robot\"] = self.robot`` 创建了 ``articulations`` "
"字典的一个新的 ``robot`` 元素，并将值设置为 ``self.robot`` 。"

#: ../../source/setup/walkthrough/api_env_design.rst:151
msgid ""
"Notice also that the remaining functions do not take additional arguments "
"except ``_reset_idx``.  This is because the environment only manages the "
"application of actions to the agent being simulated, and then updating the "
"sim.  This is what the ``_pre_physics_step`` and ``_apply_action`` steps are"
" for: we set the drive commands to the robot so that when the simulation "
"steps forward, the actions are applied and the joints are driven to new "
"targets. This process is broken into steps like this in order to ensure "
"systematic control over how the environment is executed, and is especially "
"important in the manager workflow. A similar relationship exists between the"
" ``_get_dones`` function and ``_reset_idx``.  The former, ``_get_dones`` "
"determines if each of the environments is in a terminal state, and populates"
" tensors of boolean values to indicate which environments terminated due to "
"entering a terminal state vs time out (the two returned tensors of the "
"function).  The latter, ``_reset_idx`` takes a list environment index values"
" (integers) and then actually resets those environments.  It is important "
"that things like updating drive targets or resetting environments do not "
"happen **during** the physics or rendering steps, and breaking up the "
"interface in this way helps prevent that."
msgstr ""
"还请注意，其余函数除了 ``_reset_idx`` 不接受附加参数之外。这是因为环境只管理将动作应用于正在模拟的智能体，并更新模拟。这就是 "
"``_pre_physics_step`` 和 ``_apply_action`` 步骤的作用: "
"我们设置机器人的驱动命令，这样当模拟向前走时，动作被应用并关节被驱动到新的目标。这样分步处理的过程旨在确保对环境的执行有系统性控制，并且在管理工作流中特别重要。类似的关系也存在于"
" ``_get_dones`` 函数和 ``_reset_idx`` 之间。前者， ``_get_dones`` "
"确定每个环境是否处于终端状态，并生成表示哪些环境因进入终端状态而中止，而哪些因超时而中止的布尔值张量。后者， ``_reset_idx`` "
"会取一个环境索引值（整数）的列表，然后实际重置这些环境。重要的是，像更新驱动目标或重置环境这样的操作不应该发生在物理或渲染步骤 **期间** "
"，因此通过这种方式分割接口有助于防止这种情况发生。"
