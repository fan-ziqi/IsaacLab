# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022-2024, The Isaac Lab Project Developers.
# This file is distributed under the same license as the Isaac Lab package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Isaac Lab 1.0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-04 11:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Ziqi Fan <fanziqi614@gmail.com>\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Generated-By: Babel 2.15.0\n"

#: ../../source/features/motion_generators.rst:2
msgid "Motion Generators"
msgstr "运动发生器"

#: ../../source/features/motion_generators.rst:4
msgid ""
"Robotic tasks are typically defined in task-space in terms of desired end-"
"effector trajectory, while control actions are executed in the joint-space. "
"This naturally leads to *joint-space* and *task-space* (operational-space) "
"control methods. However, successful execution of interaction tasks using "
"motion control often requires an accurate model of both the robot "
"manipulator as well as its environment. While a sufficiently precise "
"manipulator's model might be known, detailed description of environment is "
"hard to obtain :cite:p:`siciliano2009force`. Planning errors caused by this "
"mismatch can be overcome by introducing a *compliant* behavior during "
"interaction."
msgstr ""
"机器人任务通常以期望的末端执行器轨迹在任务空间中定义，而控制动作则在关节空间中执行。这自然地导致了 *关节空间* 和 *任务空间* (操作空间) "
"控制方法。然而，成功执行使用运动控制的交互任务通常需要准确的机器人手臂模型以及其环境的模型。虽然可能已知足够精确的机械手模型，但很难获得环境的详细描述 "
":cite:p:`siciliano2009force` 。规划错误由此不匹配可能可以通过引入在交互期间的*顺应*行为来克服。"

#: ../../source/features/motion_generators.rst:15
msgid ""
"While compliance is achievable passively through robot's structure (such as "
"elastic actuators, soft robot arms), we are more interested in controller "
"designs that focus on active interaction control. These are broadly "
"categorized into:"
msgstr "虽然通过机器人的结构（例如弹性执行器、软机器人手臂）被动地实现了顺应，但我们更感兴趣的是侧重于主动交互控制的控制器设计。这些广泛地分为："

#: ../../source/features/motion_generators.rst:20
msgid ""
"**impedance control:** indirect control method where motion deviations "
"caused during interaction relates to contact force as a mass-spring-damper "
"system with adjustable parameters (stiffness and damping). A specialized "
"case of this is *stiffness* control where only the static relationship "
"between position error and contact force is considered."
msgstr ""
"**阻抗控制 :** 在此间接控制方法中，交互期间引起的运动偏差与可调参数（刚度和阻尼）的质量-弹簧-"
"阻尼系统有关。此的一个专门情况是*刚度*控制，其中仅考虑位置误差和接触力之间的静态关系。"

#: ../../source/features/motion_generators.rst:26
msgid ""
"**hybrid force/motion control:** active control method which controls motion"
" and force along unconstrained and constrained task directions respectively."
" Among the various schemes for hybrid motion control, the provided "
"implementation is based on inverse dynamics control in the operational space"
" :cite:p:`khatib1987osc`."
msgstr ""
"**混合力/运动控制 :** "
"主动控制方法，沿着无约束和约束任务方向分别控制运动和力。在混合运动控制的各种方案中，提供的实施是基于操作空间中的逆动力学控制 "
":cite:p:`khatib1987osc` 。"

#: ../../source/features/motion_generators.rst:33
msgid ""
"To provide an even broader set of motion generators, we welcome "
"contributions from the community. If you are interested, please open an "
"issue to start a discussion!"
msgstr "为了提供更广泛的运动产生器，我们欢迎社区的贡献。如果您有兴趣，请打开一个议题来开始讨论！"

#: ../../source/features/motion_generators.rst:38
msgid "Joint-space controllers"
msgstr "关节空间控制"

#: ../../source/features/motion_generators.rst:41
msgid "Torque control"
msgstr "力矩控制"

#: ../../source/features/motion_generators.rst:43
#: ../../source/features/motion_generators.rst:59
#: ../../source/features/motion_generators.rst:82
msgid "Action dimensions: ``\"n\"`` (number of joints)"
msgstr "动作维度： ``\"n\"`` （关节数量）"

#: ../../source/features/motion_generators.rst:45
msgid ""
"In torque control mode, the input actions are directly set as feed-forward "
"joint torque commands, i.e. at every time-step,"
msgstr "在力矩控制模式下，输入动作直接设置为前馈关节力矩命令，即在每个时间步长，"

#: ../../source/features/motion_generators.rst:48
msgid "\\tau = \\tau_{des}"
msgstr "\\tau = \\tau_{des}"

#: ../../source/features/motion_generators.rst:52
msgid ""
"Thus, this control mode is achievable by setting the command type for the "
"actuator group, via the :class:`ActuatorControlCfg` class, to ``\"t_abs\"``."
msgstr ""
"因此，通过将执行器组的命令类型设置为 ``\"t_abs\"`` ，可以实现该控制模式，通过 :class:`ActuatorControlCfg` "
"类。"

#: ../../source/features/motion_generators.rst:57
msgid "Velocity control"
msgstr "速度控制"

#: ../../source/features/motion_generators.rst:61
msgid ""
"In velocity control mode, a proportional control law is required to reduce "
"the error between the current and desired joint velocities. Based on input "
"actions, the joint torques commands are computed as:"
msgstr "在速度控制模式下，需要比例控制定律来减少当前和期望关节速度之间的误差。根据输入动作，关节力矩指令计算如下："

#: ../../source/features/motion_generators.rst:64
msgid "\\tau = k_d (\\dot{q}_{des} - \\dot{q})"
msgstr "\\tau = k_d (\\dot{q}_{des} - \\dot{q})"

#: ../../source/features/motion_generators.rst:68
msgid "where :math:`k_d` are the gains parsed from configuration."
msgstr "其中 :math:`k_d` 是从配置解析的增益。"

#: ../../source/features/motion_generators.rst:70
msgid ""
"This control mode is achievable by setting the command type for the actuator"
" group, via the :class:`ActuatorControlCfg` class, to ``\"v_abs\"`` or "
"``\"v_rel\"``."
msgstr ""
"通过将执行器组的命令类型设置为 ``\"v_abs\"`` 或 ``\"v_rel\"`` 类，可以实现该控制模式，通过 "
":class:`ActuatorControlCfg` 类。"

#: ../../source/features/motion_generators.rst:75
msgid ""
"While performing velocity control, in many cases, gravity compensation is "
"required to ensure better tracking of the command. In this case, we suggest "
"disabling gravity for the links in the articulation in simulation."
msgstr "在执行速度控制时，通常需要重力补偿，以确保更好地跟踪命令。在这种情况下，建议在模拟中为关节禁用重力。"

#: ../../source/features/motion_generators.rst:80
msgid "Position control with fixed impedance"
msgstr "带有固定阻抗的位置控制"

#: ../../source/features/motion_generators.rst:84
msgid ""
"In position control mode, a proportional-damping (PD) control law is "
"employed to track the desired joint positions and ensuring the articulation "
"remains still at the desired location (i.e., desired joint velocities are "
"zero). Based on the input actions, the joint torque commands are computed "
"as:"
msgstr ""
"在位置控制模式下，采用比例-"
"阻尼（PD）控制律来跟踪期望的关节位置，并确保在期望位置上关节保持静止（即期望关节速度为零）。根据输入动作，关节力矩指令计算如下："

#: ../../source/features/motion_generators.rst:88
msgid "\\tau = k_p (q_{des} - q)  - k_d \\dot{q}"
msgstr "\\tau = k_p (q_{des} - q) - k_d \\dot{q}"

#: ../../source/features/motion_generators.rst:92
msgid ""
"where :math:`k_p` and :math:`k_d` are the gains parsed from configuration."
msgstr "其中 :math:`k_p` 和 :math:`k_d` 是根据配置解析的增益。"

#: ../../source/features/motion_generators.rst:94
msgid ""
"In its simplest above form,  the control mode is achievable by setting the "
"command type for the actuator group, via the :class:`ActuatorControlCfg` "
"class, to ``\"p_abs\"`` or ``\"p_rel\"``."
msgstr ""
"在其最简单的形式上，可以通过将执行器组的命令类型设置为 ``\"p_abs\"`` 或 ``\"p_rel\"`` ，以实现此控制模式，通过 "
":class:`ActuatorControlCfg` 类。"

#: ../../source/features/motion_generators.rst:97
msgid ""
"However, a more complete formulation which considers the dynamics of the "
"articulation would be:"
msgstr "然而，一个更完整的公式化考虑了关节动力学，即："

#: ../../source/features/motion_generators.rst:99
msgid "\\tau = M \\left( k_p (q_{des} - q)  - k_d \\dot{q} \\right) + g"
msgstr "\\tau = M \\left( k_p (q_{des} - q) - k_d \\dot{q} \\right) + g"

#: ../../source/features/motion_generators.rst:103
msgid ""
"where :math:`M` is the joint-space inertia matrix of size :math:`n \\times "
"n`, and :math:`g` is the joint-space gravity vector. This implementation is "
"available through the :class:`JointImpedanceController` class by setting the"
" impedance mode to ``\"fixed\"``. The gains :math:`k_p` are parsed from the "
"input configuration and :math:`k_d` are computed while considering the "
"system as a decoupled point-mass oscillator, i.e.,"
msgstr ""
"其中 :math:`M` 是关节空间惯性矩阵，维度为 :math:`n \\times n` ， :math:`g` "
"是关节空间重力矢量。通过将阻抗模式设置为 ``\"固定\"`` ，可以通过 :class:`JointImpedanceController` "
"类中的该实现。从输入配置解析增益 :math:`k_p` 的同时考虑系统作为分离点质量振荡器。"

#: ../../source/features/motion_generators.rst:108
msgid "k_d = 2 \\sqrt{k_p} \\times D"
msgstr "k_d = 2 \\sqrt{k_p} \\times D"

#: ../../source/features/motion_generators.rst:112
msgid ""
"where :math:`D` is the damping ratio of the system. Critical damping is "
"achieved for :math:`D = 1`, overcritical damping for :math:`D > 1` and "
"undercritical damping for :math:`D < 1`."
msgstr ""
"其中 :math:`D` 是系统的阻尼比。当 :math:`D = 1` 时实现临界阻尼， :math:`D > 1` 时实现过临界阻尼， "
":math:`D < 1` 时实现欠临界阻尼。"

#: ../../source/features/motion_generators.rst:115
msgid ""
"Additionally, it is possible to disable the inertial or gravity compensation"
" in the controller by setting the flags :attr:`inertial_compensation` and  "
":attr:`gravity_compensation` in the configuration to :obj:`False`, "
"respectively."
msgstr ""
"此外，可以通过将配置中的标志 :attr:`inertial_compensation` 和 :attr:`gravity_compensation` "
"设置为 :obj:`False` ，在控制器中禁用惯性或重力补偿。"

#: ../../source/features/motion_generators.rst:120
msgid "Position control with variable stiffness"
msgstr "带有可变刚度的位置控制"

#: ../../source/features/motion_generators.rst:122
msgid "Action dimensions: ``\"2n\"`` (number of joints)"
msgstr "动作维度： ``\"2n\"`` （关节数量）"

#: ../../source/features/motion_generators.rst:124
msgid ""
"In stiffness control, the same formulation as above is employed, however, "
"the gains :math:`k_p` are part of the input commands. This implementation is"
" available through the :class:`JointImpedanceController` class by setting "
"the impedance mode to ``\"variable_kp\"``."
msgstr ""
"在刚度控制中，使用与上述相同的公式，然而，增益 :math:`k_p` 是输入命令的一部分。通过将阻抗模式设置为 ``\"可变普\"`` ，可以通过 "
":class:`JointImpedanceController` 类中的该实现。"

#: ../../source/features/motion_generators.rst:129
msgid "Position control with variable impedance"
msgstr "带有可变阻抗的位置控制"

#: ../../source/features/motion_generators.rst:131
msgid "Action dimensions: ``\"3n\"`` (number of joints)"
msgstr "动作维度： ``\"3n\"`` （关节数量）"

#: ../../source/features/motion_generators.rst:133
msgid ""
"In impedance control, the same formulation as above is employed, however, "
"both :math:`k_p` and :math:`k_d` are part of the input commands. This "
"implementation is available through the :class:`JointImpedanceController` "
"class by setting the impedance mode to ``\"variable\"``."
msgstr ""
"在阻抗控制中，采用与上述相同的公式，然而，增益 :math:`k_p` 和 :math:`k_d` 是输入命令的一部分。通过将阻抗模式设置为 "
"``\"变量\"`` ，可以通过 :class:`JointImpedanceController` 类中的该实现。"

#: ../../source/features/motion_generators.rst:138
msgid "Task-space controllers"
msgstr "任务空间控制器"

#: ../../source/features/motion_generators.rst:141
msgid "Differential inverse kinematics (IK)"
msgstr "差分逆运动学（IK）"

#: ../../source/features/motion_generators.rst:143
msgid ""
"Action dimensions:  ``\"3\"`` (relative/absolute position), ``\"6\"`` "
"(relative pose), or ``\"7\"`` (absolute pose)"
msgstr "动作维度： ``\"3\"`` （相对/绝对位置） , ``\"6\"`` （相对姿态） , 或 ``\"7\"`` （绝对姿态）"

#: ../../source/features/motion_generators.rst:145
msgid ""
"Inverse kinematics converts the task-space tracking error to joint-space "
"error. In its most typical implementation, the pose error in the task-sace, "
":math:`\\Delta \\chi_e = (\\Delta p_e, \\Delta \\phi_e)`, is computed as the"
" cartesian distance between the desired and current task-space positions, "
"and the shortest distance in :math:`\\mathbb{SO}(3)` between the desired and"
" current task-space orientations."
msgstr ""
"逆运动学将任务空间追踪误差转换为关节空间误差。在其最典型的实施中，任务空间中的姿势误差， :math:`\\Delta \\chi_e = "
"(\\Delta p_e, \\Delta \\phi_e)` ，被计算为期望和当前任务空间位置之间的笛卡尔距离，以及期望和当前任务空间方向之间 "
":math:`\\mathbb{SO}(3)` 中的最短距离。"

#: ../../source/features/motion_generators.rst:150
msgid ""
"Using the geometric Jacobian :math:`J_{eO} \\in \\mathbb{R}^{6 \\times n}`, "
"that relates task-space velocity to joint-space velocities, we design the "
"control law to obtain the desired joint positions as:"
msgstr ""
"使用 :math:`J_{eO} \\in \\mathbb{R}^{6 \\times n}` "
"的几何雅克比矩阵，将任务空间速度与关节空间速度联系起来，我们通过设计控制律来获得期望的关节位置："

#: ../../source/features/motion_generators.rst:153
msgid "q_{des} = q + \\eta J_{eO}^{-} \\Delta \\chi_e"
msgstr "q_{des} = q + \\eta J_{eO}^{-} \\Delta \\chi_e"

#: ../../source/features/motion_generators.rst:157
msgid ""
"where :math:`\\eta` is a scaling parameter and :math:`J_{eO}^{-}` is the "
"pseudo-inverse of the Jacobian."
msgstr "其中 :math:`\\eta` 是一个缩放参数， :math:`J_{eO}^{-}` 是雅克比的伪逆。"

#: ../../source/features/motion_generators.rst:159
msgid ""
"It is possible to compute the pseudo-inverse of the Jacobian using different"
" formulations:"
msgstr "可以使用不同的公式计算伪逆雅克比矩阵："

#: ../../source/features/motion_generators.rst:161
msgid "Moore-Penrose pseduo-inverse: :math:`A^{-} = A^T(AA^T)^{-1}`."
msgstr "Moore-Penrose伪逆 : :math:`A^{-} = A^T(AA^T)^{-1}`."

#: ../../source/features/motion_generators.rst:162
msgid ""
"Levenberg-Marquardt pseduo-inverse (damped least-squares): :math:`A^{-} = "
"A^T (AA^T + \\lambda \\mathbb{I})^{-1}`."
msgstr ""
"Levenberg-Marquardt伪逆（阻尼最小二乘） : :math:`A^{-} = A^T (AA^T + \\lambda "
"\\mathbb{I})^{-1}`."

#: ../../source/features/motion_generators.rst:163
msgid "Tanspose pseudo-inverse: :math:`A^{-} = A^T`."
msgstr "转置伪逆 : :math:`A^{-} = A^T`."

#: ../../source/features/motion_generators.rst:164
msgid ""
"Adaptive singular-vale decomposition (SVD) pseduo-inverse from "
":cite:t:`buss2004ik`."
msgstr "自适应奇异值分解（SVD）伪逆来源 :cite:t:`buss2004ik`."

#: ../../source/features/motion_generators.rst:166
msgid ""
"These implementations are available through the "
":class:`DifferentialInverseKinematics` class."
msgstr "这些实现可以通过 :class:`DifferentialInverseKinematics` 类进行。[Google 翻译]"

#: ../../source/features/motion_generators.rst:169
msgid "Impedance controller"
msgstr "阻抗控制器"

#: ../../source/features/motion_generators.rst:172
msgid ""
"It uses task-space pose error and Jacobian to compute join torques through "
"mass-spring-damper system with a) fixed stiffness, b) variable stiffness "
"(stiffness control), and c) variable stiffness and damping (impedance "
"control)."
msgstr ""
"它使用任务空间姿势误差和雅可比矩阵，通过固定刚度a）、可变刚度（刚度控制）b）、可变刚度和阻尼（阻抗控制）的质量-弹簧-阻尼系统来计算关节力矩。"

#: ../../source/features/motion_generators.rst:177
msgid "Operational-space controller"
msgstr "运行空间控制器"

#: ../../source/features/motion_generators.rst:179
msgid ""
"Similar to task-space impedance control but uses the Equation of Motion "
"(EoM) for computing the task-space force"
msgstr "类似于任务空间阻抗控制，但使用运动方程（EoM）来计算任务空间力"

#: ../../source/features/motion_generators.rst:184
msgid "Closed-loop proportional force controller"
msgstr "闭环比例力控制器"

#: ../../source/features/motion_generators.rst:186
msgid ""
"It uses a proportional term to track the desired wrench command with respect"
" to current wrench at the end-effector."
msgstr "它使用比例项来跟踪期望的力矩指令相对于末端执行器当前力矩的情况。"

#: ../../source/features/motion_generators.rst:191
msgid "Hybrid force-motion controller"
msgstr "混合力-运动控制器"

#: ../../source/features/motion_generators.rst:193
msgid ""
"It combines closed-loop force control and operational-space motion control "
"to compute the desired wrench at the end-effector. It uses selection "
"matrices that define the unconstrainted and constrained task directions."
msgstr "它结合了闭环力控制和运行空间运动控制，以计算末端执行器的期望力矩。它使用定义未受约束和受约束任务方向的选择矩阵。"

#: ../../source/features/motion_generators.rst:200
msgid "Reactive planners"
msgstr "反应式规划器"

#: ../../source/features/motion_generators.rst:202
msgid ""
"Typical task-space controllers do not account for motion constraints such as"
" joint limits, self-collision and environment collision. Instead they rely "
"on high-level planners (such as RRT) to handle these non-Euclidean "
"constraints and give joint/task-space way-points to the controller. However,"
" these methods are often conservative and have undesirable deceleration when"
" close to an object. More recently, different approaches combine the "
"constraints directly into an optimization problem, thereby providing a "
"holistic solution for motion generation and control."
msgstr ""
"典型的任务空间控制器不考虑关节限位、自身碰撞和环境碰撞等运动约束。相反，它们依赖于高级规划器（如RRT）来处理这些非欧几里德约束，并给出关节/任务空间的路标给控制器。然而，这些方法通常保守，并且在靠近物体时有不良的减速。最近，不同的方法将约束直接结合到优化问题中，从而为运动生成和控制提供了整体解决方案。"

#: ../../source/features/motion_generators.rst:212
msgid "We currently support the following planners:"
msgstr "我们目前支持以下规划器："

#: ../../source/features/motion_generators.rst:214
msgid ""
"**RMPFlow (lula):** An acceleration-based policy that composes various "
"Reimannian Motion Policies (RMPs) to solve a hierarchy of tasks "
":cite:p:`cheng2021rmpflow`. It is capable of performing dynamic collision "
"avoidance while navigating the end-effector to a target."
msgstr ""
"**RMPFlow（lula）：**这是一种基于加速度的策略，由多个Reimannian Motion Policies "
"(RMPs)组成，用于解决任务层次结构问题 :cite:p:`cheng2021rmpflow` 。 它可以在将末端执行器导航到目标的同时执行动态避碰。"

#: ../../source/features/motion_generators.rst:218
msgid ""
"**MPC (OCS2):** A receding horizon control policy based on sequential "
"linear-quadratic (SLQ) programming. It formulates various constraints into a"
" single optimization problem via soft-penalties and uses automatic "
"differentiation to compute derivatives of the system dynamics, constraints "
"and costs. Currently, we support the MPC formulation for end-effector "
"trajectory tracking in fixed-arm and mobile manipulators. The formulation "
"considers a kinematic system model with joint limits and self-collision "
"avoidance :cite:p:`mittal2021articulated`."
msgstr ""
"**MPC（OCS2）：**这是一种基于顺序线性二次（SLQ）规划的滚动视域控制策略。它通过软惩罚将各种约束转化为单个优化问题，并使用自动微分来计算系统动力学、约束和代价的导数。目前，我们支持MPC公式用于固定臂和移动机械手的末端执行器轨迹跟踪。该公式考虑了具有关节限位和自身碰撞避免的运动学系统模型"
" :cite:p:`mittal2021articulated` 。"

#: ../../source/features/motion_generators.rst:227
msgid ""
"We wrap around the python bindings for these reactive planners to perform a "
"batched computing of robot actions. However, their current implementations "
"are CPU-based which may cause certain slowdown for learning."
msgstr ""
"我们包装了这些反应式规划器的Python绑定，以执行机器人动作的批处理计算。然而，它们目前的实现是基于CPU的，这可能导致学习过程中的一定减速。"
